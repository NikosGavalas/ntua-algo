\documentclass[12pt,a4paper]{article}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  right=20mm,
  top=20mm
}

\usepackage[utf8]{inputenc}
\usepackage[english, greek]{babel}
\usepackage[LGR, T1]{fontenc} 

\usepackage{amsmath}

\usepackage{tikz}

\usepackage{titlesec}
\titleformat{\section}{\large}{}{0em}{\textsc}[\titlerule]
\titleformat{\subsection}{\large}{}{0em}{\textbf}[]
\titleformat{\subsubsection}{}{}{0em}{\textit}[]

\title{Αλγόριθμοι και Πολυπλοκότητα}
\author{Γαβαλάς Νίκος, AM 03113121}
\date{Νοέμβριος 2018}

\begin{document}

  \maketitle

  \begin{center}
    \Large{2η Γραπτή Σειρά Ασκήσεων}
  \end{center}

  \section{Άσκηση 1}

  \subsection{α}
  
  \subsubsection{α.1}

    Κανένα από τα τρία άπληστα κριτήρια δεν οδηγούν σε βέλτιστη
    λύση. Παρακάτω δίδονται ένα αντιπαράδειγμα για κάθε κριτήριο: \\
    \\
    \underline{Λιγότερες Επικαλύψεις:}
    \\
    \begin{center}
      \begin{tikzpicture}
        \draw (-2.75, 0) -- node[above] {1} (-1.75, 0);
        \draw (-1.25, 0) -- node[above] {2} (-0.25, 0);
        \draw (0.25, 0) -- node[above] {3} (1.25, 0);
        \draw (1.75, 0) -- node[above] {4} (2.75, 0);

        \draw (-2, 1) -- node[above] {5} (-1, 1);
        \draw (-0.5, 1) -- node[above] {6} (0.5, 1);
        \draw (1, 1) -- node[above] {7} (2, 1);
        
        \draw (-2, 2) -- node[above] {8} (-1, 2);
        \draw (1, 2) -- node[above] {9} (2, 2);

        \draw (-2, 3) -- node[above] {10} (-1, 3);
        \draw (1, 3) -- node[above] {11} (2, 3);
      \end{tikzpicture}
    \end{center}
    Εδώ βέλτιστη επιλογή είναι \( |\{1, 2, 3, 4\}| = 4 \) αλλά
    επιλέγεται η \( |\{6, 1, 4\}| = 3 \) \\
    \\
    \underline{Μεγαλύτερη Διάρκεια:}\\
    \\
    \begin{center}
      \begin{tikzpicture}
        \draw (-0.5, 1) -- node[above] {1} (1, 1);
        \draw (-1.25, 0) -- node[above] {2} (-0.25, 0);
        \draw (0.25, 0) -- node[above] {3} (3.25, 0);
      \end{tikzpicture}
    \end{center}
    Εδώ βέλτιστη είναι η \( |\{2, 3\}| = 2 \) αλλά επιλέγεται η \( |\{2\}| = 1 
    \) \\
    \\
    \underline{Περισσότερες Επικαλύψεις:} \\
    \\
    \begin{center}
      \begin{tikzpicture}
        \draw (-2.75, 0) -- node[above] {1} (-1.75, 0);
        \draw (-1.25, 0) -- node[above] {2} (-0.25, 0);
        \draw (0.25, 0) -- node[above] {3} (1.25, 0);
        \draw (-2, 1) -- node[above] {4} (-1, 1);
        \draw (-0.5, 1) -- node[above] {5} (0.5, 1);
        \draw (-0.5, 2) -- node[above] {6} (0.5, 2);
        \draw (-0.5, 3) -- node[above] {7} (0.5, 3);
        \draw (-2, 2) -- node[above] {8} (-1, 2);
        \draw (-2, 3) -- node[above] {9} (-1, 3);
      \end{tikzpicture}
    \end{center}
    Εδώ βέλτιστη είναι η \( |\{ 1, 2, 3\}| = 3 \) αλλά επιλέγεται κάποια σαν 
    την \( |\{ 1, 3 \}| = 2 \)

  \subsubsection{α.2}

    Αρχικά ταξινομούμε τα χρονικά διαστήματα ως προς τα \( f_i \) (χρόνοι 
    ολοκλήρωσης) σε \( O(n\log{n}) \).\\
    \\
    Ύστερα κατασκευάζουμε έναν βοηθητικό πίνακα \( prev \), κάθε
    στοιχείο του οποίου είναι ο δείκτης \( i \) του χρονικού διαστήματος που
    η διάρκεια του ολοκληρώνεται αμέσως πριν την έναρξη του \( i \)-οστού και
    δεν έχει επικάλυψη με αυτό. Ο πίνακας αυτός δημιουργείται σε χρόνο \( O(n
    \log{n}) \), αφού για κάθε μάθημα \( i \) από τα \( n \) κάνουμε μια δυαδική
    αναζήτηση σε \( O(\log{n}) \) για να βρούμε τη θέση του προηγούμενου.\\
    \\
    Έχοντας τώρα τον \( prev \), κατασκευάζουμε την αναδρομική σχέση:
    \[ creds[i] = \max\{ creds[prev[i]] + w[i], creds[i - 1] \} \]
    , όπου \( creds[1] = w[1] \).\\
    \\
    Με την σχέση αυτή βρίσκουμε το ζητούμενο, \( creds[n] \), σε γραμμικό
    χρόνο.\\
    \\
    Επομένως συνολικά κάνουμε χρόνο \( O(n\log{n}) \).

  \subsection{β}

    Ταξινομούμε αρχικά τα μαθήματα ως προς τους χρόνους ολοκλήρωσης \( f_i \).
    Θεωρώντας ότι ανακοίνωση τη στιγμή \( f_i \) περιλαμβάνει και τους φοιτητές
    του \( i \)-οστού τμήματος, επιλέγουμε χρονική στιγμή ανακοίνωσης τον 
    χρόνο ολοκλήρωσης του πρώτου ((ακάλυπτου)) διαστήματος που βρίσκουμε,
    αφαιρούμε τα διαστήματα που επικαλύπτονται με αυτή την επιλογή και
    συνεχίζουμε στο επόμενο ακάλυπτο.\\
    \\
    Η εύρεση (και διαγραφή - μαρκάρισμα) των επικαλυπτόμενων μπορεί να γίνει σε
    λογαριθμικό χρόνο αν ταξινομήσουμε μια δεύτερη φορά ως προς τους χρόνους
    έναρξης.\\
    \\
    \underline{Ορθότητα:} Έστω \( O^{*} \) μια βέλτιστη λύση και \( Ο \) η δικη
    μας. Έστω ότι οι δύο αλγόριθμοι που αντιστοιχούν σε αυτές διαφέρουν για
    πρώτη φορά κατά την επιλογή της χρονικής στιγμής \( i \). Υποθέτουμε επίσης
    ότι ο βέλτιστος αλγόριθμος, στο σημείο που οι δύο λύσεις διαφέρουν για πρώτη
    φορά επιλέγει τη χρονική στιγμή \( ο^{*} \) ενώ ο δικός μας την \( ο = f_k 
    \).
    \begin{itemize}
      \item Αν \( o^{*} < o \), ο βέλτιστος αλγόριθμος έχει επιλέξει χρονική
            στιγμή που καλύπτει τουλάχιστον όσα ο δικός μας, αφού μετά τη χρ.
            στιγμή που οι αλγόριθμοι δίνουν ίδια λύση και πρίν την
            \( f_k \) δεν τελειώνει άλλο διάστημα ενδιάμεσα.
      \item Αν \( o^{*} > o \), ο βέλτιστος αλγόριθμος χάνει το διάστημα
            \( [s_k, f_k) \), άρα δεν ορθός.
    \end{itemize}
    Επομένως \( ο = ο^{*} \).
  
  \section{Άσκηση 2}

    Έχουμε \( f_i, p_i, u_i \) να είναι αντίστοιχα η τιμή της δύναμης του \( i 
    \)-οστού σφυριού, οι τιμές των δυνάμεων που χρειάζεται το \( i \)-οστό κουτί
    για να σπάσει, και τα ευρώ που κερδίζονται από το \( i \)-οστό κουτί.\\
    \\
    Αρχικά ταξινομούμε ως προς \( u_i \) τα κουτιά, και ύστερα ξεκινώντας από τα
    κουτιά με τη μεγαλύτερη αμοιβή, βλέπουμε για κάθε ένα πόση δύναμη χρειάζεται
    για να σπάσει, οπότε έπειτα βρίσκουμε από τα διαθέσιμα σφυριά ποιό είναι
    εκείνο με την ελάχιστη \( f_i \) που μπορεί να το σπάσει (\( f_i \ge p_i \))
    .\\
    \\
    To {\latintext lookup} για το σφυρί με αυτό το χαρακτηριστικό μπορεί να
    γίνει σε χρόνο \( Ο(\log{n}) \) με μια δυαδική αναζήτηση, αφού πρώτα
    ((πληρώσουμε)) χρόνο \( Ο(n\log{n}) \) για να τα ταξινομήσουμε.\\
    \\
    Αφού βρούμε ποιο σφυρί χρειάζεται, το αφαιρούμε από τη λίστα με τα σφυριά.
    Αυτό μπορεί να γίνει αποδοτικά (μαζί με τη διαδικασία της αναζήτησης) με
    χρήση ενός {\latintext Binary Search Tree} (ή ακόμα καλύτερα με χρήση ενός
    {\latintext AVL Tree} για να έχουμε διαγραφή σε λογαριθμικό χρόνο σίγουρα)
    .\\
    \\
    Η πολυπλοκότητα του αλγορίθμου αυτού είναι \( O(n\log{n} + n\log{n} +
    n(\log{n} + \log{n})) = O(n\log{n}) \).
    % TODO: απόδειξη ορθότητας;;;

  \section{Άσκηση 3}
  
    Έστω \( n \) οι χώρες, με \( k_i \)
    αναμνηστικά η καθεμία, και \( c_{ij}, p_{ij} \) το κόστος και η
    ((συναισθηματική αξία)) του καθενός από αυτά. Θέλουμε να επιλέξουμε το πολύ
    ένα από κάθε χώρα, ώστε το \( \sum{p_{ij}} \) τους να είναι μέγιστο με τον
    περιορισμό \( \sum{c_{ij}} \le C \).\\
    \\
    Αρχικά κατασκευάζουμε έναν βοηθητικό πίνακα \( prev \) σε γραμμικό χρόνο του
    οποίου κάθε στοιχείο είναι δείκτης στο τελευταίο της αμέσως προηγούμενης
    χώρας, χρησιμοποιώντας ως {\latintext indexing} των αναμνηστικών το
    \( i = 1, ..., \sum_{j=0}^{n}{k_j} \). Για παράδειγμα, αν έχουμε 3 χώρες με
    2 υποψήφια αναμνηστικά η καθεμία, το i θα παίρνει τιμές από 1 ως 6, και ο
    πίνακας \( prev \) θα έχει τα στοιχεία \( [1, 2, 2, 2, 4, 4] \).\\
    \\
    Mε αυτά τα δεδομένα, μπορούμε στο πρόβλημα να εφαρμόσουμε την εξής
    αναδρομική σχέση που αποτελεί τροποποίηση του {\latintext knapsack} για να
    βρούμε τη λύση:
    \[ opt(i, c) = \max\{ opt(i - 1, c), opt(prev[i], c - c_i) + p_i \} \]
    Η αναδρομική αυτή σχέση εκφράζει ότι η βέλτιστη λύση (η συνολική
    συναισθηματική αξία) μέχρι το \( i \)-οστό αντικείμενο,
    για {\latintext budget} \( c \), είναι ίση με το μέγιστο μεταξύ της
    βέλτιστης λύσης για μέχρι το \( (i - 1) \)-οστό αντικείμενο και ίδιο
    {\latintext budget} \( c \), και της βέλτιστης λύσης αυξημένης κατά \( p_i
    \), για μέχρι το \( prev[i] \)-οστό αντικείμενο και
    {\latintext budget} \( c \) μείον την αξία του αντικείμενου.\\
    \\
    Mε χρήση του πίνακα \( prev \) δηλαδή κατ' αυτόν τον τρόπο, αν συμπεριληφθεί
    στη βέλτιστη λύση ένα αντικείμενο που ανήκει σε μία χώρα, αγνοούνται τα
    υπόλοιπα αντικείμενα της ίδιας χώρας αφού κοιτάμε υποπροβλήματα για \( i \)
    που ανήκει στην προηγούμενη χώρα.\\
    \\
    H λύση που ψάχνουμε είναι η \( opt(\sum_{j=0}^{n}{k_j}, C) \).
    Ο αλγόριθμος αυτός υλοποιείται όπως το {\latintext knapsack}, με χρήση
    πίνακα δηλαδή, και έχει χρονική πολυπλοκότητα \( O(C\sum_{j=0}^{n}{k_j}) \). 

  \section{Άσκηση 4}

  
  
  \section{Άσκηση 5}

    Έχουμε \( n \) κεραίες που μπορούν να  λειτουργούν ως πομποί ή δέκτες,
    καταναλώνοντας αντίστοιχα ενέργεια \( (T_i, R_i) \), με \( R_i \le T_i \),
    και θέλουμε να τις χωρίσουμε όλες σε ζευγάρια με τρόπο τέτοιο ώστε η
    συνολική κατανάλωση του δικτύου να είναι η ελάχιστη δυνατή.\\
    \\
    Το ότι ισχύει \( R_i \le T_i \) σημαίνει ότι η διαφορά \( T_i - R_i \)
    είναι πάντα μη αρνητική. Το γεγονός αυτό μας επιτρέπει να ακολουθήσουμε την
    εξής άπληστη προσέγγιση: Έστω ότι μέχρι την \( i \)-οστή
    κεραία έχουμε βέλτιστη λύση και θέλουμε να αποφασίσουμε ως τι θα 
    λειτουργεί η επόμενη κεραία.
    \begin{itemize}
      \item Αν είναι το \( i \) περιττός, τότε κάνουμε 
            την κεραία \( i + 1 \) δέκτη, και προσθέτουμε το \( R_i \) στην
            συνολική κατανάλωση.
      \item Αν είναι το \( i \) άρτιος, τότε κάνουμε την \( i + 1 \) κεραία
            δέκτη (και προσθέτουμε \( R_i \) στη συνολική κατανάλωση), αλλά αυτή
            τη φορά πρέπει κάποιος δέκτης από τα προηγούμενα να
            γίνει πομπός, γιατί πρέπει συνολικά τα ζεύγη να είναι \( n/2 \).
    \end{itemize}
    Σχετικά με την επιλογή του πομπού, γίνεται πομπός αυτός που τελικά θα μας
    εξασφαλίσει ελάχιστη συνολική ενέργεια (και αυτό είναι που εξασφαλίζει και
    τη βελτιστότητα), δηλαδή ο πομπός \( j \) στον οποίο αντιστοιχεί η μικρότερη
    διαφορά \( T_j - R_j \). Τη διαφορά αυτή την ((παρακολουθούμε)) αποδοτικά
    με χρήση ενός {\latintext min-heap} με στοιχεία τα ζεύγη \( (Τ_i - R_i,
    i) \).\\
    \\
    O αλγόριθμος αυτός κάνει \( Ο(n\log{n}) \) για την κατασκευή του {\latintext
    heap}, και ύστερα για κάθε στοιχείο \( n \) κάνει \( O(1) \) για την
    εύρεση της ελάχιστης διαφοράς και \( \log{n} \) για να αναδιατάξει το
    {\latintext heap}, οπότε έχει συνολικά χρονική πολυπλοκότητα \( O(n\log{n})
    \).

\end{document}
