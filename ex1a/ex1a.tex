\documentclass[12pt,a4paper]{article}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  right=20mm,
  top=20mm
}

\usepackage[utf8]{inputenc}
\usepackage[english, greek]{babel}
\usepackage[LGR, T1]{fontenc} 

\usepackage{amsmath}

\usepackage{titlesec}
\titleformat{\section}{\large}{}{0em}{\textsc}[\titlerule]
\titleformat{\subsection}{\large}{}{0em}{\textbf}[]
\titleformat{\subsubsection}{}{}{0em}{\textit}[]

\title{Αλγόριθμοι και Πολυπλοκότητα}
\author{Γαβαλάς Νίκος, AM 03113121}
\date{Οκτώβριος 2018}

\begin{document}

  \maketitle

  \begin{center}
    \Large{1η Γραπτή Σειρά Ασκήσεων}
  \end{center}

  \section{Άσκηση 1}

  \subsection{α}

    Τελική διάταξη:

    \begin{enumerate}
      \item \( \sum_{k=1}^{n}k2^{-k}  \)
      \item \( (\log{n})^2/\log\log{n}  \)
      \item \( \log(\binom{n}{\log{n}})  \)
      \item \( \log^{4}n \)
      \item \( \log(n!)/(\log{n})^3 \)
      \item \( \log(\binom{2n}{n}), n2^{2^{2^{100}}}=\Theta(n) \)
      \item \( n^2 \)
      \item \( n^3/(\log{n})^8 \)
      \item \( \binom{n}{6}=\Theta(n^6) \)
      \item \( (\log_{2}{n})^{\log_{2}{n}} \)
      \item \( (\sqrt{n})^{\log_{2}\log_{2}(n!)} \)
      \item \( 2^{(\log_{2}{n})^4}=\Theta(n^{\log^3{n}}) \)
      \item \( \sum_{k=1}^{n}k2^k, n\sum_{k=0}^{n}\binom{n}{k}=\Theta(n2^n) \)
      \item \( (\sqrt{n})! \)
    \end{enumerate}

  \subsection{β}

    \begin{enumerate}
      \item \( T(n) = 2T(n/3) + n\log{n} : n^{\log_{3}2 \approx 0.63 }, 
      nlogn = f(n) = \Omega(n^{\log_{3}2}) \), ικανοποιεί την {\latintext 
      regularity condition}, άρα \textit{Περίπτωση 3} και \( T(n)=\Theta(n\log{n}) \)
      \item \( T(n) = 3T(n/3) + n\log{n} : n^{\log_{3}3} + nlogn, nlogn = 
      f(n) = \Omega(n) \), δεν ικανοποιεί όμως την {\latintext regularity 
      condition}, αφού διαφέρουν κατά λογαριθμικό όρο, όχι πολυωνυμικό. Με δέντρο 
      αναδρομής εύκολα φαίνεται ότι \( \Theta(n\log^{2}{n}) \)
      \item \( T(n) = 4T(n/3) + n\log{n} : n^{\log_{3}{4} \approx 1.26}, n\log{n} =
      f(n) = O(n^{\log_{3}4}) \), άρα \textit{Περίπτωση 1} και \( Τ(n) = 
      \Theta(n^{\log_{3}{4}}) \)
      \item \( T(n) = T(n/2) + T(n/3) + n : \) βλέπουμε ότι \( \frac{n}{2} + 
      \frac{n}{3} < n \), οπότε λογικά \( T(n) = \Theta(n) \) (απόδειξη με δέντρο
      αναδρομής)
      \item \( Τ(n) = T(n/2) + T(n/3) + T(n/6) + n : \) εδώ ισχύει \( \frac{n}{2} 
      + \frac{n}{3} + \frac{n}{6} = n \), οπότε κάνοντας δέντρο αναδρομής βλέπουμε
      πώς \( \Theta(n\log{n}) \) 
      \item \( T(n) = T(n^{5/6}) + \Theta(\log{n}) : \) ...
      \item \( T(n) = T(n/4) + \sqrt{n} : \) θέτουμε \(n=k^2\) και η αναδρομική 
      σχέση γίνεται \( U(k) = U(k/2) + \Theta(k) \) με \( U(k)=T(k^2) \). Από 
      {\latintext MT}, \( U(k)=\Theta(k) \Rightarrow T(k^2)=\Theta(k) \Rightarrow 
      T(n)=\Theta(\sqrt{n}) \)
    \end{enumerate}

  \section{Άσκηση 2}

  \subsection{α}

  \subsubsection{1.}
    Πραγματοποιούμε {\latintext quickselect} στον πίνακα και βρίσκουμε τον
    {\latintext median} των στοιχείων σε χρόνο \( Ο(n) \).
    Ύστερα κάνουμε {\latintext partition} τον πίνακα χρησιμοποιώντας τον
    {\latintext median} ως {\latintext pivot}, που παίρνει χρόνο επίσης \( Ο(n) \), 
    και τέλος κάνουμε αναδρομικά την ίδια διαδικασία στα δύο {\latintext partitioned} 
    κομμάτια.
    Με δέντρο αναδρομής φαίνεται άμεσα ότι η πολυπλοκότητα του αλγορίθμου
    αυτού είναι \( Ο(n\log{k}) \).

  \subsubsection{2.}
    Με βάση τον άνωθι αλγόριθμο, ταξινομούμε το καθένα από τα \( k \) κομμάτια
    σε χρόνο \( Ο(\frac{n}{k}\log{\frac{n}{k}}) \) το καθένα.
    Συνολικά έχουμε \( k \) κομμάτια, οπότε ο χρόνος για όλον τον πίνακα θα 
    είναι \( k\cdot O(\frac{n}{k}\log{\frac{n}{k}})=O(n\log{\frac{n}{k}}) \).
    Ο χρόνος αυτός είναι βέλτιστος για συγκριτικό αλγόριθμο, και αυτό επειδή 
    οποιοσδήποτε συγκριτικός αλγόριθμος ταξινόμησης ξέρουμε ότι δεν γίνεται να 
    έχει χρόνο καλύτερο από \( O(n\log{n}) \), αφού για \(n\) στοιχεία υπάρχουν
    \(n!\) συνδυασμοί αυτών, και πραγματοποιώντας σε κάθε βήμα μία σύγκριση 
    μειώνουμε το \(n!\) σε \(\frac{n!}{2}\). 
    Άρα συνολικά δηλαδή θα θέλουμε χρόνο \(\log_{2}(n!) = \Theta(n\log_{2}{n})\)
    (από {\latintext Stirling's approximation}).
  
  \subsection{β}
    Έστω \( m \) το πλήθος των διαφορετικών στοιχείων του \( Α \). Αρχικά 
    κάνουμε κάτι σαν {\latintext mergesort}, όπου χωρίζουμε τον πίνακα σε δύο
    μέρη και δουλεύουμε αναδρομικά, με τη διαφορά ότι στο βήμα της συγχώνευσης
    όταν βρούμε διπλότυπο στοιχείο, το πετάμε. Έτσι προκύπτει ένας νεός πίνακας
    \( Α' \), που έχει ακριβώς \( m \) στοιχεία ταξινομημένα. Η διαδικασία αυτή
    γίνεται σε χρόνο \( m\log{n} \) αφού \( T(n)=2T(n/2)+\Theta(m) \). Ύστερα
    έχοντας αυτόν τον \( Α' \) πίνακα, διασχίζουμε τον \( Α \) και για κάθε 
    στοιχείο αυτού κάνουμε δυαδική αναζήτηση στον \(  Α' \) και βρίσκουμε σε 
    ποια θέση είναι εκεί, οπότε αυξάνουμε έναν {\latintext counter} σε έναν 
    πίνακα με {\latintext counters} στην αντίστοιχη θέση. Τέλος, από τον πίνακα
    \( Α' \) και αυτόν με τους {\latintext counters}, σχηματίζουμε τον αρχικό, 
    ταξινομημένο. Η τελευταία διαδικασία χρειάζεται χρόνο \( n\log{m} \).
    Τώρα αν \( m=O(\log^d{n}) \), η συνολική πολυπλοκότητα είναι \( \Theta
    (\log^d{n}\log{n} + n\log{\log^d{n}}) = \Theta(dn\log{\log{n}}) =
    \Theta(n\log{\log{n}}) \).

  \section{Άσκηση 3}

  \subsection{α}
    Ξεκινάμε θέτοντας σε μια μεταβλητή {\latintext "min"} τη τιμή
    \(|A_{1}[0] - A_{2}[0]|\) και αρχικοποιώντας τους \(i\) και \(j\) στις
    αρχές των δύο πινάκων. Ύστερα σε {\latintext loop} αυξάνουμε το
    {\latintext index} που αντιστοιχεί στο στοιχείο με τη μικρότερη τιμή, και
    κάνουμε {\latintext update} την {\latintext min} όταν μειώνεται η διαφορά,
    μέχρι να δείξει σε τιμή που ξεπερνάει αυτή του στοιχείου που δείχνει το άλλο
    {\latintext index}, οπότε ύστερα αυξάνουμε το άλλο (που τώρα έχει δείχνει
    στο μικρότερο από τα δύο), έως ότου βρούμε διαφορά μηδέν ή φτάσει ένας
    από τους δείκτες στα όρια του πίνακα του.\\
    Ο αλγόριθμος είναι ορθός γιατί για να μειωθεί η διαφορά, αρκεί να αυξηθεί
    η τιμή του μικρότερου όρου ή να μειωθεί η τιμή του μεγαλύτερου. Όμως εδώ
    επειδή είναι ταξινομημένοι οι πίνακες, μπορούμε μόνο να μειώσουμε τη
    διαφορά αυξάνοντας τον μικρότερο, οπότε κάνουμε αυτό έως ότου βρούμε
    στοιχείο που υπερβαίνει την τιμή που δείχνει ο άλλος δείκτης όπου και
    αρχίζουμε να μετακινούμε τον άλλον.\\
    Σε ό,τι αφορά χρόνική πολυπλοκότητα, ο αλγόριθμος είναι γραμμικού χρόνου
    αφού για κάθε στοιχείο καθενός πίνακα πραγματοποιούμε μια σύγκριση που
    μειώνει το μέγεθος του προβλήματος κατά ένα στοιχείο.
    Άρα \( \Theta(n_1n_2) \).

  \subsection{β}
    Εντελώς ανάλογα με το 1ο ερώτημα, ξεκινάμε με 3 δείκτες στην αρχή του κάθε
    πίνακα και πραγματοποιύμε ακριβώς την ίδια διαδικασία, αυξάνοντας τον
    δείκτη που δείχνει στο μικρότερο στοιχείο σε σύγκριση με τα στοιχεία που
    δείχνουν οι υπόλοιποι, και σε κάθε αύξηση επανυοπολογίζουμε {\latintext
    min} και {\latintext max} και κάνουμε {\latintext update} τη διαφορά. 
    Η διαδικασία αυτή χρόνο \(\Theta(m\sum_{k=1}^{m}n_k)\) αφού σε κάθε βήμα
    χρειαζόμαστε χρόνο \(m\) για να βρούμε τα {\latintext min-max}. Είναι 
    ορθός για τον ίδιο λόγο που είναι και ο αλγόριθμος του \textit{α} ερωτήματος.
  
  \subsection{γ}
    Η διαδικασία εύρεσης {\latintext min-max} σε κάθε βήμα μπορεί να επιταχυνθεί 
    με χρήση ενός {\latintext max-heap }και ενός {\latintext min-heap}. Θα 
    χρειάζεται χρόνος \( \log{m} \) για την αναδιάταξη των στοιχείων σε κάθε 
    βήμα αλλά θα έχουμε το {\latintext min} και το {\latintext max} σε χρόνο 
    \( Ο(1) \).
    Έτσι η τελική πολυπλοκότητα είναι \(\Theta(\log{m}\sum_{k=1}^{m}n_k)\)

  \section{Άσκηση 4}

  \subsection{α}
    Αριθμούμε τις φιάλες στο δυαδικό, και χρησιμοποιούμε \(log_{2}{1000000}
    \approx 20 \) δοκιμαστές, στους οποίους λέμε να δοκιμάσουν ο 1ος τις φιάλες
    με \(LSB=bit_{0}=1\), o 2ος εκείνες με \(bit_{1}=1\) και ούτω καθεξής.
    Μετά από 24 ώρες τους διατάσσουμε βάσει του \(bit\) που δοκίμαζε ο καθένας
    και όποιος έχει επηρεαστεί από το φίλτρο τον μετράμε ως 1, αντιθέτως 0.
    Ο δυαδικός που σχηματίζεται αντιστοιχεί στη φιάλη που αναζητούμε. Η 
    πολυπλοκότητα της λύσης αυτής είναι \( \Theta(\log{n}) \).

  \subsection{β}
    Κατ' αρχάς, η μέγιστη ημερήσια αποστάση είναι προφανώς τουλάχιστον ίση με τη
    μέγιστη από τις \( d_i \), και το πολύ ίση με το \( \sum_{i=k}^{n}d_i \)
    (αφού μπορούμε να βάλουμε σε κάθε μέρα και από μία πόλη και στο τέλος 
    όσες περισσεύουν να τις βάλουμε μαζεμένες στην τελευταία μέρα).
    Αυτές οι δύο τιμές ορίζουν ένα εύρος. Αυτό που μπορούμε λοιπόν να κάνουμε
    είναι για κάθε τιμή σε αυτό το εύρος, να ακολουθήσουμε την εξής τακτική:
    Για κάθε πόλη, αν η \( d_i \) χωράει στην τρέχουσα τιμή, τη προσθέτουμε,
    αν όχι, μηδενίζουμε το τρέχον άθροισμα και αλλάζουμε μέρα. Αφού τρέξουμε
    όλες τις πόλεις και έχουμε \{πλήθος ημερών\}\( <= k \), κρατάμε το 
    {\latintext max}.
    Τέλος για κάθε τιμή του εύρους κρατάμε το μικρότερο {\latintext max}, και
    επιστρέφουμε το μικρότερο όλων.
    Η πολυπλοκότητα της λύσης αυτής είναι \( O(n\sum_{i=1}^{n}d_i) \).
    Νομίζω ότι μπορούμε να κάνουμε δυαδική αναζήτηση στις τιμές του εύρους αλλά
    δεν είμαι σίγουρος (αυτό θα μείωνε την πολυπλοκότητα σε 
    \( O(n\log{\sum_{i=1}^{n}d_i)} \).)
  
  \section{Άσκηση 5}

  \subsection{α}
    Για την εύρεση του \( k \)-οστού μικρότερου ξεκινάμε με κλήση της 
    \( F_S{(\frac{M}{2})} \). Αν το αποτέλεσμα είναι \( <k \), καλούμε
    την \( F_S{(\frac{M}{2} + \frac{M}{4})} \), διαφορετικά την
    \( F_S{(\frac{M}{2} - \frac{M}{4})} \), κ.ο.κ. (ή απλά θέτουμε
    \( M=M/2 \) και συνεχίζουμε αναδρομικά στο κομμάτι που είναι το \( k \)).
    Πρακτικά κάνουμε δυαδική αναζήτηση δηλαδή.\\
    Η πολυπλοκότητα είναι αυτή της δυαδικής αναζήτησης, δηλαδή
    \( \Theta(\log{M}) \) (υποθέτοντας φυσικά ότι η \( F_S \) είναι 
    \( \Theta(1) \).
  
  \subsection{β}
    Το πρόβλημα λύνεται με τον αλγόριθμο του \textit{α} ερωτήματος, αρκεί να
    βρούμε έναν τρόπο να υπολογήσουμε την αντίστοιχη \( F_S \). Για να πετύχουμε
    αποδοτική υλοποίηση, αρχικά ταξινομούμε τα στοιχεία του συνόλου. Η διαδικασία
    αυτή παίρνει χρόνο \( \Theta(n\log{n}) \). Ύστερα, για να βρούμε το πλήθος
    των διαφορών που δεν υπερβαίνουν το \( \ell \), δηλαδή την \( F_S(\ell) \),
    για κάθε στοιχείο \( i \) του ταξινομημένου πίνακα \( A\) κάνουμε δυαδική 
    αναζήτηση για να βρούμε το \( A[i] + \ell \) και κάνουμε {\latintext 
    accumulate} το πλήθος των στοιχείων μεταξύ του \( Α[i] + \ell \) και του 
    \( A[i] \), παίρνουμε δηλαδή τη διαφορά των δεικτών. Η \( F_S \) ύστερα 
    γυρίζει το {\latintext accumulated} άθροισμα.\\
    Η \( F_S \) κάνει έτσι χρόνο \( n \) για να διατρέξει τον πίνακα και 
    χρόνο \( \log{n} \) για κάθε στοιχείο του λόγω της δυαδικής αναζήτησης.
    Οπότε συνολικά μαζί με την αρχική ταξινόμηση κάνει χρόνο \( \Theta(n\log{n}
    + n\log{n})=\Theta(n\log{n}) \).
    Όταν αυτή η \( F_S \) συνδυαστεί με την δυαδική αναζήτηση στον χώρο των τιμών
    της (βλ. ερώτημα \textit{α}), ο τελικός αλγόριθμος κάνει χρόνο \( \Theta
    (n\log{n}\log{M}) \).
\end{document}
