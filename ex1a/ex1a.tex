\documentclass[12pt,a4paper]{article}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  right=20mm,
  top=20mm
}

\usepackage[utf8]{inputenc}
\usepackage[english, greek]{babel}
\usepackage[LGR, T1]{fontenc}

\usepackage{amsmath}

\usepackage{titlesec}
\titleformat{\section}{\large}{}{0em}{\textsc}[\titlerule]
\titleformat{\subsection}{\large}{}{0em}{\textbf}[]
\titleformat{\subsubsection}{}{}{0em}{\textit}[]

\title{Αλγόριθμοι και Πολυπλοκότητα}
\author{Γαβαλάς Νίκος, AM 03113121}
\date{Οκτώβριος 2018}

\begin{document}

  \maketitle

  \begin{center}
    \Large{1η Γραπτή Σειρά Ασκήσεων}
  \end{center}

  \section{Άσκηση 1}

  \subsection{α}
    Αρχική κατηγοριοποίηση: \\
    \\
    \begin{tabular}{ c c }
      \hline
      Εκθετικές &  \\
      Σχεδόν Πολυωνυμικές &  \\
      Πολυωνυμικές &  \\
      Υπογραμμικές &  \\
      \hline
    \end{tabular}\\
    \\
    \\
    Τελική διάταξη:\\
    \\
    \( n^2, 2^{(\log_{2}{n})^4}, \log(n!)/(\log{n})^3, \\
    n2^{2^{2^{100}}}, \log(\binom{n}{\log{n}}), (\log{n})^2/\log\log{n},\\
    \log^{4}n, (\sqrt{n})!, \binom{n}{6}, n^3/(\log{n})^8, (\log_{2}{n})^{\log_{2}{n}},\\
    \log(\binom{2n}{n}), n\sum_{k=0}^{n}\binom{n}{k}, (\sqrt{n})^{\log_{2}\log_{2}(n!)}, \sum_{k=1}^{n}k2^k,
    \sum_{k=1}^{n} k2^{-k} \)\\
    \\
    Σχόλια:

  \subsection{β}

    \begin{enumerate}
      \item \( T(n) = 2T(n/3) + n\log{n} : n^{\log_{3}2 \approx 0.63 }, nlogn = f(n) = \Omega(n^{\log_{3}2}) \), ικανοποιεί την {\latintext regularity condition}, άρα \textit{Περίπτωση 3} και \( T(n)=\Theta(n\log{n}) \)
      \item \( T(n) = 3T(n/3) + n\log{n} : n^{\log_{3}3} + nlogn, nlogn = f(n) = \Omega(n) \), δεν ικανοποιεί όμως την {\latintext regularity condition}, αφού διαφέρουν κατά λογαριθμικό όρο, όχι πολυωνυμικό. Με δέντρο αναδρομής εύκολα φαίνεται ότι \( \Theta(n\log^{2}{n}) \)
      \item \( T(n) = 4T(n/3) + n\log{n} : n^{\log_{3}{4} \approx 1.26}, n\log{n} = f(n) = O(n^{\log_{3}4}) \), άρα \textit{Περίπτωση 1} και \( Τ(n) = \Theta(n^{\log_{3}{4}}) \)
      \item \( T(n) = T(n/2) + T(n/3) + n : \) βλέπουμε ότι \( \frac{n}{2} + \frac{n}{3} < n \), οπότε λογικά \( T(n) = \Theta(n) \) (απόδειξη με δέντρο αναδρομής)
      \item \( Τ(n) = T(n/2) + T(n/3) + T(n/6) + n : \)
      \item \( T(n) = T(n^{5/6}) + \Theta(\log{n}) : \)
      \item \( T(n) = T(n/4) + \sqrt{n} : \) θέτουμε \(n=k^2\) και η αναδρομική σχέση γίνεται \( U(k) = U(k/2) + \Theta(k) \) με \( U(k)=T(k^2) \). Από {\latintext MT}, \( U(k)=\Theta(k) \Rightarrow T(k^2)=\Theta(k) \Rightarrow T(n)=\Theta(\sqrt{n}) \)
    \end{enumerate}

  \section{Άσκηση 2}

  \subsection{α}

  \subsubsection{1.}
    Πραγματοποιούμε {\latintext quickselect} στον πίνακα και βρίσκουμε τον
     {\latintext median} των στοιχείων σε χρόνο \( Ο(n) \).
    Ύστερα κάνουμε {\latintext partition} τον πίνακα χρησιμοποιώντας τον
     {\latintext median} ως {\latintext pivot}, που παίρνει χρόνο επίσης \( Ο(n) \), και τέλος κάνουμε αναδρομικά την ίδια διαδικασία στα δύο {\latintext partitioned} κομμάτια.
    Με δέντρο αναδρομής φαίνεται άμεσα ότι η πολυπλοκότητα του αλγορίθμου
     αυτού είναι \( Ο(n\log{k}) \).

  \subsubsection{2.}
    Με βάση τον άνωθι αλγόριθμο, ταξινομούμε το καθένα από τα \( k \) κομμάτια
    σε χρόνο \( Ο(\frac{n}{k}\log{\frac{n}{k}}) \) το καθένα.
    Συνολικά έχουμε \( k \) κομμάτια, οπότε ο χρόνος για όλον τον πίνακα θα 
    είναι \( k\cdot O(\frac{n}{k}\log{\frac{n}{k}})=O(n\log{\frac{n}{k}}) \).
    Ο χρόνος αυτός είναι βέλτιστος για συγκριτικό αλγόριθμο, και αυτό επειδή 
    οποιοσδήποτε συγκριτικός αλγόριθμος ταξινόμησης ξέρουμε ότι δεν γίνεται να 
    έχει χρόνο καλύτερο από \( O(n\log{n}) \), αφού για \(n\) στοιχεία υπάρχουν
    \(n!\) συνδυασμοί αυτών, και πραγματοποιώντας σε κάθε βήμα μία σύγκριση 
    μειώνουμε το \(n!\) σε \(\frac{n!}{2}\). 
    Άρα συνολικά δηλαδή θα θέλουμε χρόνο \(\log_{2}(n!) = \Theta(n\log_{2}{n})\).
  
  \subsection{β}

  \section{Άσκηση 3}

  \subsection{α}
    Ξεκινάμε θέτοντας σε μια μεταβλητή {\latintext "min"} τη τιμή
    \(|A_{1}[0] - A_{2}[0]|\) και αρχικοποιώντας τους \(i\) και \(j\) στις
    αρχές των δύο πινάκων. Ύστερα σε {\latintext loop} αυξάνουμε το
    {\latintext index} που αντιστοιχεί στο στοιχείο με τη μικρότερη τιμή, και
    κάνουμε {\latintext update} την {\latintext min} όταν μειώνεται η διαφορά,
    μέχρι να δείξει σε τιμή που ξεπερνάει αυτή του στοιχείου που δείχνει το άλλο
    {\latintext index}, οπότε ύστερα αυξάνουμε το άλλο (που τώρα έχει δείχνει
    στο μικρότερο από τα δύο), έως ότου βρούμε διαφορά μηδέν ή φτάσει ένας
    από τους δείκτες στα όρια του πίνακα του.\\
    Ο αλγόριθμος είναι ορθός γιατί για να μειωθεί η διαφορά, αρκεί να αυξηθεί
    η τιμή του μικρότερου όρου ή να μειωθεί η τιμή του μεγαλύτερου. Όμως εδώ
    επειδή είναι ταξινομημένοι οι πίνακες, μπορούμε μόνο να μειώσουμε τη
    διαφορά αυξάνοντας τον μικρότερο, οπότε κάνουμε αυτό έως ότου βρούμε
    στοιχείο που υπερβαίνει την τιμή που δείχνει ο άλλος δείκτης όπου και
    αρχίζουμε να μετακινούμε τον άλλον.\\
    Σε ό,τι αφορά χρόνική πολυπλοκότητα, ο αλγόριθμος είναι γραμμικού χρόνου
    αφού για κάθε στοιχείο καθενός πίνακα πραγματοποιούμε μια σύγκριση που
    μειώνει το μέγεθος του προβλήματος κατά ένα στοιχείο.
    Άρα \( \Theta(n_1n_2) \).

  \subsection{β}
    Εντελώς ανάλογα με το 1ο ερώτημα, ξεκινάμε με 3 δείκτες στην αρχή του κάθε
    πίνακα και πραγματοποιύμε ακριβώς την ίδια διαδικασία, αυξάνοντας τον
    δείκτη που δείχνει στο μικρότερο στοιχείο σε σύγκριση με τα στοιχεία που
    δείχνουν οι υπόλοιποι, και σε κάθε αύξηση επανυοπολογίζουμε {\latintext
    min} και {\latintext max} και κάνουμε {\latintext update} τη διαφορά. 
    Η διαδικασία αυτή χρόνο \(\Theta(m\sum_{k=1}^{m}n_k)\) αφού σε κάθε βήμα 
    χρειαζόμαστε χρόνο \(m\) για να βρούμε τα {\latintext min-max}. Είναι 
    ορθός για τον ίδιο λόγο που είναι και ο αλγόριθμος του \textit{α} ερωτήματος.
  
  \subsection{γ}

  \section{Άσκηση 4}

  \subsection{α}
    Αριθμούμε τις φιάλες στο δυαδικό, και χρησιμοποιούμε \(log_{2}{1000000}
    \approx 20 \) δοκιμαστές, στους οποίους λέμε να δοκιμάσουν ο 1ος τις φιάλες
    με \(LSB=bit_{0}=1\), o 2ος εκείνες με \(bit_{1}=1\) και ούτω καθεξής.
    Μετά από 24 ώρες τους διατάσσουμε βάσει του \(bit\) που δοκίμαζε ο καθένας
    και όποιος έχει επηρεαστεί από το φίλτρο τον μετράμε ως 1, αντιθέτως 0.
    Ο δυαδικός που σχηματίζεται αντιστοιχεί στη φιάλη που αναζητούμε.
  
  \subsection{β}

  \section{Άσκηση 5}

  \subsection{α}
    Για την εύρεση του \( k \)-οστού μικρότερου ξεκινάμε με κλήση της 
    \( F_S{(\frac{M}{2})} \). Αν το αποτέλεσμα είναι \( <k \), καλούμε
    την \( F_S{(\frac{M}{2} + \frac{M}{4})} \), διαφορετικά την
    \( F_S{(\frac{M}{2} - \frac{M}{4})} \), κ.ο.κ. (ή απλά θέτουμε
    \( M=M/2 \) και συνεχίζουμε αναδρομικά στο κομμάτι που είναι το \( k \)).
    Πρακτικά κάνουμε δυαδική αναζήτηση δηλαδή.\\
    Η πολυπλοκότητα είναι αυτή της δυαδικής αναζήτησης, δηλαδή
    \( \Theta(\log{M}) \) (υποθέτοντας φυσικά ότι η \( F_S \) είναι 
    \( \Theta(1) \).
  
  \subsection{β}
    Το πρόβλημα λύνεται με τον αλγόριθμο του \textit{α} ερωτήματος, αρκεί να
    βρούμε έναν τρόπο να υπολοιήσουμε την αντίστοιχη \( F_S \). Για να πετύχουμε
    αποδοτική υλοποίηση, αρχικά ταξινομούμε τα στοιχεία του συνόλου. Η διαδικασία
    αυτή παίρνει χρόνο \( \Theta(n\log{n}) \). Ύστερα, για να βρούμε το πλήθος
    των διαφορών που δεν υπερβαίνουν το \( \ell \), δηλαδή την \( F_S(\ell) \),
    για κάθε στοιχείο \( i \) του ταξινομημένου πίνακα \( A\) κάνουμε δυαδική αναζήτηση για να βρούμε
    το \( A[i] + \ell \) και κάνουμε {\latintext accumulate} το πλήθος των στοιχείων
    μεταξύ του \( Α[i] + \ell \) και του \( A[i] \), παίρνουμε δηλαδή τη διαφορά
    των δεικτών. Η \( F_S \) ύστερα γυρίζει το {\latintext accumulated} άθροισμα.\\
    Η \( F_S \) κάνει έτσι χρόνο \( n \) για να διατρέξει τον πίνακα και 
    χρόνο \( \log{n} \) για κάθε στοιχείο του λόγω της δυαδικής αναζήτησης.
    Οπότε συνολικά μαζί με την αρχική ταξινόμηση κάνει χρόνο \( \Theta(n\log{n}
    + n\log{n})=\Theta(n\log{n}) \).
    Όταν αυτή η \( F_S \) συνδυαστεί με την δυαδική αναζήτηση στον χώρο των τιμών
    της (βλ. ερώτημα \textit{α}), ο τελικός αλγόριθμος κάνει χρόνο \( \Theta
    (n\log{n}\log{M}) \).
\end{document}
